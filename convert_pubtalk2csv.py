import os.path
import sys
from pathlib import Path
import ollama
#from ollama import chat, generate
#import markitdown
from markitdown import MarkItDown
from enum import Enum

# note only gemma 3 works
model_dict = {
    "GEMMA": "gemma3", # ok
    "CODELLAMA": "codellama", # very slow
    "LLAMA": "llama3.2", # no good
    "TINYLLAMA": "tinyllama", # no good
    "MISTRAL": "mistral", # no good
    "QWEN": "qwen3:30b", # takes forever
    "SMOLLM": "smollm:135m", # bad
    "STARCODER": "starcoder:3b" # bad
}
model = model_dict['GEMMA']

PROMPT_DIR = 'prompts/'
PT_DIR = 'pubtalk-word-docs/'
PT_2025_SEPT = 'Lecture titles - September 2025.docx'
PT_2025_AUG =  'Lecture titles - August 2025.docx'
PT_2025_JULY = 'Lecture titles - July 2025.docx'


TOOL_NAME = 'Convert docx file containing Public talk titles into CSV ready to import to Wix'

def call_chat():
    response: ollama.ChatResponse = ollama.chat(model='gemma3', messages=[
      {
        'role': 'user',
        'content': 'Why is the sky blue?',
      },
    ])
    print(response['message']['content'])
    # or access fields directly from the response object
    print(response.message.content)

def _print_content(header, content):
    print(f'\n{header}\nvvv\n{content}\n^^^\n')

def _write_to_file(content_text, filename, force=False):
    """
    Takes the content and removes the markdown meta deta fore and aft. Writes it into a csv file.
    :param content_text: This to be written to file
    :param filename: Full path name to file
    :param force: t will not overwrite an existing file unless this flag is set.
    :return: True if sucessful write of the file. False otherwise
    """
    if os.path.exists(filename) and force is False:
        print(f'File already exists >>{filename}<<')
        return False

    try:
        with open(filename, "w") as f:
            f.write(content_text)
    except PermissionError:
        print(f'Failed to write file >>{filename}<<')
        return False
    return True


def _convert_word_doc(fullname):
    splitup = os.path.splitext(fullname)
    # filename = splitup[0]
    file_ext = splitup[1]
    if file_ext != '.docx':
        raise ValueError(f'File format not supported. Only support .docx extension')
    md = MarkItDown()
    result = md.convert(source=fullname)
    return result.text_content # result


def prompt_on_expanded_text(prompt_text, text_to_process):
    print(f'\nProcessing using "{model}" LLM ... Please be patient')
    my_prompt = prompt_text + f' {text_to_process}'
    response = ollama.generate(model=model, prompt=my_prompt)
    the_resp = response['response']
    return the_resp


def obtain_pure_csv(full_text):
    """
    The csv generated by the LLM wrappers the pure csv.
    Removes the header and footer around the csv.
    :param full_text:
    :return: pure_csv
    """
    string_array = full_text.splitlines()
    first = string_array[0]
    last = string_array[-1]
    if first != "```csv" or last != "```":
        #print(f'The header line is >>{first}<<')
        raise ValueError(f'Header or footer is invalid. Header is "{first}". Footer is "{last}"')
        #return "incorrect header"
    pure_csv_array = string_array[1:-1]
    pure_csv_string = "\n".join(pure_csv_array)
    return pure_csv_string


def convert_pt_word_doc_to_csv_for_wix_import(fname):
    print(f'{TOOL_NAME}')
    full_doc_name = PT_DIR + fname

    print(f'Input file is "{full_doc_name}"')
    cwd = os.getcwd()

    print(f'\t(Path is relative to "{cwd}")')

    doc_abs_path = os.path.abspath(full_doc_name)

    doc_path_to_use = full_doc_name # doc_abs_path
    #print(f'Output is to same directory with a .csv extension.')


    # Convert word (docx) to markdown
    content_in_md_format = _convert_word_doc(doc_path_to_use)


    # obtain the prompt text
    full_prompt = PROMPT_DIR + 'prompt_extract_csv4wix_from_pt_word_document.txt'
    with open(full_prompt, 'r') as file:
        extract_prompt = file.read()

    wrappered_csv_output = prompt_on_expanded_text(extract_prompt, content_in_md_format)

    _print_content(f'Derived CSV from "{fname}" is:', wrappered_csv_output)
    # convert wrappered CSV to pure csv (the LLM uses the ```csv  header)
    csv_output = obtain_pure_csv(wrappered_csv_output)

    split_doc_name = os.path.splitext(doc_path_to_use)
    filename_without_extension = split_doc_name[0]
    #print(f'Filename without extension >>{filename_without_extension}<<')

    full_csv_name = filename_without_extension + '.csv'
    if _write_to_file(csv_output, full_csv_name, force=True):
        print(f'Successfully generated file at "{full_csv_name}"')
        print(f'\t(Path is relative to "{cwd}")')
    else:
        #print(f'Failed to write file')
        mesg = 'Failed to write file'
        sys.exit(mesg)


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    #print_hi('PyCharm')
    #call_chat()
    #convert_pt_word_doc_to_csv_for_wix_import(PT_2025_JULY)
    #convert_pt_word_doc_to_csv_for_wix_import(PT_2025_AUG)
    convert_pt_word_doc_to_csv_for_wix_import(PT_2025_SEPT)


# See PyCharm help at https://www.jetbrains.com/help/pycharm/
